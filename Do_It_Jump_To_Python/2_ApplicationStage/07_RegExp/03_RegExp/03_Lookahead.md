# 전방 탐색
전방탐색(Lookahead Asserions) 확장 구문을 알아보자.  
정규식 안에 이 확장 구문을 사용하면 암호문 처럼 알아보기 어렵지만,  
전방 탐색이 꼭 필요한 경우가 있으며 매우 유용한 경우도 많으니 꼭 알아보자.  
  
```
>>> p = re.compile( '.+:' )
>>> m = p.search( 'http://google.com' )
>>> print( m.group() )
http:
```
정규식 `.+:`과 일치하는 문자열로 http:를 돌려주었다.  
만약 http:라는 검색 결과에서 :를 제외하고 출력하려면 어떻게 해야 할까?  
이럴 때 사용하는 것이 전방 탐색이다.  
전방 탐색에는 긍정(Positive)과 부정(Negative)의 2동류가 있고 다음과 같이 표현한다.  
- 긍정형 전방 탐색( `(?=...)` ) : `...`에 해당되는 정규식과 매치되어야 하며 조건이 통과 되어도 문자열이 소비되지 않는다.
- 부정형 전방 탐색 ( `?!...)` ) : `...`에 해당되는 정규식과 매치되지 않아야 하며 조건이 통과 되어도 문자열이 소비되지 않는다.

## 긍정형 전방 탐색
긍정형 전방 탐색을 사용하면 http:의 결과를 http로 바꿀 수 있다.
```
>>> p = re.compile( '.+(?=:)' )
>>> m = p.search( 'http:google.com' )
>>> print( m.group() )
http
```
  
정규식 중 `:`에 해당하는 부분에 긍정형 전방 탐색 기법을 적용하여 `(?=:)`으로 변경하였다.  
이렇게 되면 기존 정규식과 검색에서 동일한 효과를 발휘하지만 `:`에 해당하는 문자열이 정규식 엔진에 의해 소비되지 않어(검색에는 포함되지만 검색 결과에는 제외됨) 검색 결과에서는 `:`이 제거된 후 돌려주는 효과가 있다.  
  
```
.*[.].*$
 ```
이 정규식은 `파일 이름 + . + 확장자` 를 나타내는 정규식이다.  
이 정규식은 foo.bar, autoexec.bat, sendmail.cf 같은 형식의 파일과 매치될 것이다.  
이 정규식에 확장자가 "bat인 파일을 제외해야 한다"는 조건을 추가해 보자.  
  
```
.*[.][^b].*$
```
이 정규식은 확장자가 b라는 문자로 시작하면 안 된다는 의미이다.  
하지만 이 정규식은 foo.bar 라는 파일마저 걸러낸다.  
  
```
.*[.]([^b]..|.[^a].|..[^t])$
```
이 정규식은 `|` 메타문자를 사용하여 확장자의 첫 번째 문자가 b가 아니거나 두 번째 문자라 a가 아니거나 세 번째 문자가 t가 아닌 경우를 의미한다.  
이 정규식에서는 foo.bar는 제외되지 않고 autoexec.bat은 제외되지만,  
sendmail.cf 처럼 확장자의 문자 개수가 2개인 케이스를 포함하지 못하는 단점이 있다.  
  
```
.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$
```
확장자의 문자 개수가 2개여도 통과 되는 정규식이 만들어 졌다.  
하지만 정규식은 점점 더 복잡해 지고 이해하기 어려워 진다.  
그런데 여기에 bat 파일 말고 다른 확장자의 파일도 제외하라는 조건이 추가된다면 더 복잡해 질 것이다.  
  
## 부정형 전방 탐색
위 예제는 부정형 전방 탐색을 하면 다음과 같이 간단하게 처리된다.  
```
.*[.](?!bat$).*$
```
확장자가 bat가 아닌 경우에만 통과한된다는 의미이다.  
bat 문자열이 있는지 조사하는 과정에서 문자열이 소비되지 않으므로 bat가 아니라고 판단되면 그 이후 정규식 매치가 진행된다.  
exe 역시 제외하라는 조겉이 추가되면 다음과 같이 간단히 표현할 수 있다.
```
.*[.](?!bat$|exe$).*$
```
